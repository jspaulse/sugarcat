The ARMv6 architecture contains several enhancements to exception processing, to reduce interrupt handler entry and exit time:
SRS
Save return state to a specified stack frame.
RFE
Return from exception.
CPS
Directly modify the CPSR.
http://www.heyrick.co.uk/armwiki/The_Status_register <- all CPSR/SPSR, fun times!


TODO:
	Fixup domain accesses

Things that need to be set prior to MMU
Domain (Read below)

Domain:
	DACR, Domain Access Control Register, VMSA
	MRC p15, 0, <Rt>, c3, c0, 0 ; Read DACR into Rt
	MCR p15, 0, <Rt>, c3, c0, 0 ; Write Rt to DACR
	
	Initially, write 0b11 into DACR (Manager, no check permissions)
		Later, after it's working, set 0b01 (Client, check permissions)
	
	Leave all pages in domain 0 (by not writing them).

===== CPSR =====
CPSR_fsxc
Where 
cpsr_c is control bits [7:0]
cpsr_x is extension bits [15:8]
cpsr_s is status bits [23:16]
cpsr_f is flag bits [31:24]

MSR     CPSR_c, xxxx      sets the control bits
MSR     CPSR_f, xxxx      sets the flag bits
MSR     CPSR_cxsf, xxxx   sets everything

=== MMU ===
We are using short descript. translation (two levels)
B3.5 short descriptor translation table format
B3-1325 has a general diagram of two levels
B3.5.1 has translation table format descriptors
B3.5.4 describes the split
B3-1337 has translation for Page Table/Page Table Directory blah

Address translation:
	First table:
		Indexed by VA [31-N:20] (for ttb0)
		Indexed by VA [31:20] (for ttb1)
	Second table:
		Indexed by VA [19:12]
	
	
DON'T TRUST MY SMALL SECTION BITS ATM

TTBCR:
[2:0]	N bits
MRC p15, 0, <Rt>, c2, c0, 2 ; Read TTBCR into Rt
MCR p15, 0, <Rt>, c2, c0, 2 ; Write RT to TTBCR

TTB1 address (in register):
	MRC p15, 0, <Rt>, c2, c0, 1 ; Read 32-bit TTBR1 into Rt
	MCR p15, 0, <Rt>, c2, c0, 1 ; Write Rt to 32-bit TTBR1
	
	Must be aligned 16KB
	[31:14]		table address
	
TTB0 address (in register):
	MRC p15, 0, <Rt>, c2, c0, 0 ; Read 32-bit TTBR0 into Rt
	MCR p15, 0, <Rt>, c2, c0, 0 ; Write Rt to 32-bit TTBR0

	In these assignments, x is (14-(TTBCR.N)). (which is the memory split)
	Must be aligned 2^(14-n)
	[31:(14-n)]	-	address
	
Entries:
	AP bits:
	0x00	No Access
	0x01	RW Kernel, No User
	0x02	RW Kernel, RO User
	0x03	RW Kernel, RW User
	
	Page Table, First Level:
		[Entry]: [1:0]
		
		Invalid: 0x0
		Section: 0x2
			[31:20]	Section Base Address, PA[31:20]
			[19]	NS		/* disregard */
			[17]	nG		
			[16]	S		
			[15]	AP[2]	/* disregard */
			[14:12] TEX
			[11:10]	AP[1:0]
			[8:5]	Domain
			[4]		XN		Execute Never
			[3]		C
			[2]		B
			
		Page Directory(?): 0x1
			[31:10] Page table base address
			[8:5]	Domain	/* disregard	*/
			[3]		NS		/* disregard	*/
			[2]		PXN		/* disregard	*/
			
	Page Table, Second Level:
		Invalid: 0x0
		Small Page: 0x2
		[31:12]		Page Base Address, PA[31:12]
		[11]		nG
		[10]		S
		[9]			AP[2]	/* disregard */
		[8:6]		TEX
		[5:4]		AP[1:0]
		[3]			C
		[2]			B
		[0]			XN
		
	Page Table - [31:10], maps a 1MB range to a second level table
		Use small pages (requires 1KB?)
	Section - maps a whole 1M range
	
	

Enabling MMU SCTLR, System Control Register (B4.1.130 armv7-a ARM)
B4.1.130 SCTLR, System Control Register, VMSA

In ARMv7‑A the following have instruction set equivalents:
Instruction Synchronization Barrier.
Data Synchronization Barrier.
Data Memory Barrier.
Wait for Interrupt.

Setting the vector table base address (armv7-a ARM B4.1.156)
MCR p15, 0, <Rt>, c12, c0, 0

http://www.ethernut.de/en/documents/arm-exceptions.html
Reset:
	SVC mode, Secure Enabled

IVT:
	The Secure SCTLR.V bit determines the exception base address:
		V == 0 The Secure VBAR holds the exception base address.
		V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.
0x00	reset
0x04	undef_instr
0x08 	svc_call
0x0C	pref_abt
0x10	data_abt
0x14	unused/reserved
0x18	irq
0x1C	fiq

For the Secure vector table:
• the Secure SCTLR.V bit determines the exception base address:
V == 0 The Secure VBAR holds the exception base address.
V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.

MRS/MSR
B1.3.1
(CPSR register diagram pg B1-1148)
user: 	10000	/* user mode */
fiq: 	10001	/* has it's own r8-r12, sp/lr */
irq:	10010
svc:	10011 (Supervisor)	/* syscall */
mon:	10110 (Monitor)
abt:	10111 (Abort)
sys:	11111 (System)	/* kernel */
The exception modes are:
• FIQ mode
• IRQ mode
• Supervisor mode
• Abort mode
• Undefined mode

B1.8.10 Exception return
In the ARM architecture, exception return requires the simultaneous restoration of the PC and CPSR to values that
are consistent with the desired state of execution on returning from the exception. Typically, exception return
involves returning to one of:
• the instruction after the instruction boundary at which an asynchronous exception was taken
• the instruction following an SVC, SMC, or HMC instruction, for an exception generated by one of those
instructions
• the instruction that caused the exception, after the reason for the exception has been removed
• the subsequent instruction, if the instruction that caused the exception has been emulated in the exception
handler.
The ARM architecture defines a preferred return address for each exception other than Reset, see Link values saved
on exception entry on page B1-1172. The values of the SPSR.IT[7:0] bits generated on exception entry are always
correct for this preferred return address, but might require adjustment by the exception handler if returning
elsewhere.
In some cases, to calculate the appropriate preferred return address, a subtraction must be performed on the link
value saved on taking the exception. The description of each exception includes any value that must be subtracted
from the link value, and other information about the required exception return.

Return from an exception taken to a PL1 mode
For an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:
• Data-processing instructions with the S bit set and the PC as a destination, see SUBS PC, LR (Thumb) on
page B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.
Typically:
— a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS
instruction
— a return requiring subtraction uses SUBS with a nonzero operand.
• From ARMv6, the RFE instruction, see RFE on page B9-2000. If a subtraction is required, typically it is
performed before saving the LR value to memory.
• In ARM state, a form of the LDM instruction, see LDM (exception return) on page B9-1986. If a subtraction is
required, typically it is performed before saving the LR value to memory

=========== Data/Prefetch Abort	===========
(Is this is a thing?)
Data fetch abort
The abort was caused by the instruction at lr - 8

Instruction fetch abort
The abort was caused by the instruction at lr - 4

Read fault type:
volatile unsigned int faulttype;
__asm volatile ("mrc p15, 0, %[ft], c5, c0, 0\n\t" : [ft] "=r" (faulttype));
faulttype &= 0xf;


=========== Undefined Instruction ===========
// actual undefined instruction, for testing: 0xe7fxxxfx - ARM or A1 encoding (ARMv4T, ARMv5T, ARMv6, ARMv7)
// asm volatile (".word 0xe7f000f0\n"); /* arm illegal instruction */

(So, if I understand this correctly, LR will contain the address of the undefined instruction)
(Actually, I think the bad instruction ends up being LR - 4)
(could be wrong?)
Undefined instruction
The abort was caused by the instruction at lr

SWI and undefined instruction exceptions are
generated by the instruction itself
n lr_mode = pc + 4 //next instruction

The preferred return address for an Undefined Instruction exception is the address of the instruction that generated
the exception. This return is performed as follows:
• If returning from Secure or Non-secure Undefined mode, the exception return uses the SPSR and LR_und
values generated by the exception entry, as follows:
— If SPSR.{J, T} are both 0, indicating that the exception occurred in ARM state, the return uses an
exception return instruction with a subtraction of 4.

