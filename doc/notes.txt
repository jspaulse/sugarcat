Configuration
You configure the processor for low interrupt latency mode by use of the system control coprocessor. To ensure that a change between normal and low interrupt latency configurations is synchronized correctly, you must use software systems that only change the configuration while interrupts are disabled.
Exception processing enhancements
The ARMv6 architecture contains several enhancements to exception processing, to reduce interrupt handler entry and exit time:
SRS
Save return state to a specified stack frame.
RFE
Return from exception.
CPS
Directly modify the CPSR.
http://www.heyrick.co.uk/armwiki/The_Status_register <- all CPSR/SPSR, fun times!

===== CPSR =====
CPSR_fsxc
Where 
cpsr_c is control bits [7:0]
cpsr_x is extension bits [15:8]
cpsr_s is status bits [23:16]
cpsr_f is flag bits [31:24]

MSR     CPSR_c, xxxx      sets the control bits
MSR     CPSR_f, xxxx      sets the flag bits
MSR     CPSR_cxsf, xxxx   sets everything

=== MMU ===
Enabling MMU SCTLR, System Control Register (B4.1.130 armv7-a ARM)
B4.1.130 SCTLR, System Control Register, VMSA

In ARMv7‑A the following have instruction set equivalents:
Instruction Synchronization Barrier.
Data Synchronization Barrier.
Data Memory Barrier.
Wait for Interrupt.

Setting the vector table base address (armv7-a ARM B4.1.156)
MCR p15, 0, <Rt>, c12, c0, 0

http://www.ethernut.de/en/documents/arm-exceptions.html
Reset:
	SVC mode, Secure Enabled

IVT:
	The Secure SCTLR.V bit determines the exception base address:
		V == 0 The Secure VBAR holds the exception base address.
		V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.
0x00	reset
0x04	undef_instr
0x08 	svc_call
0x0C	pref_abt
0x10	data_abt
0x14	unused/reserved
0x18	irq
0x1C	fiq

For the Secure vector table:
• the Secure SCTLR.V bit determines the exception base address:
V == 0 The Secure VBAR holds the exception base address.
V == 1 Exception base address = 0xFFFF0000, the Hivecs setting.

MRS/MSR
B1.3.1
(CPSR register diagram pg B1-1148)
user: 	10000	/* user mode */
fiq: 	10001	/* has it's own r8-r12, sp/lr */
irq:	10010
svc:	10011 (Supervisor)	/* syscall */
mon:	10110 (Monitor)
abt:	10111 (Abort)
sys:	11111 (System)	/* kernel */
The exception modes are:
• FIQ mode
• IRQ mode
• Supervisor mode
• Abort mode
• Undefined mode

B1.8.10 Exception return
In the ARM architecture, exception return requires the simultaneous restoration of the PC and CPSR to values that
are consistent with the desired state of execution on returning from the exception. Typically, exception return
involves returning to one of:
• the instruction after the instruction boundary at which an asynchronous exception was taken
• the instruction following an SVC, SMC, or HMC instruction, for an exception generated by one of those
instructions
• the instruction that caused the exception, after the reason for the exception has been removed
• the subsequent instruction, if the instruction that caused the exception has been emulated in the exception
handler.
The ARM architecture defines a preferred return address for each exception other than Reset, see Link values saved
on exception entry on page B1-1172. The values of the SPSR.IT[7:0] bits generated on exception entry are always
correct for this preferred return address, but might require adjustment by the exception handler if returning
elsewhere.
In some cases, to calculate the appropriate preferred return address, a subtraction must be performed on the link
value saved on taking the exception. The description of each exception includes any value that must be subtracted
from the link value, and other information about the required exception return.

Return from an exception taken to a PL1 mode
For an exception taken to a PL1 mode, the ARM architecture provides the following exception return instructions:
• Data-processing instructions with the S bit set and the PC as a destination, see SUBS PC, LR (Thumb) on
page B9-2010 and SUBS PC, LR and related instructions (ARM) on page B9-2012.
Typically:
— a return where no subtraction is required uses SUBS with an operand of 0, or the equivalent MOVS
instruction
— a return requiring subtraction uses SUBS with a nonzero operand.
• From ARMv6, the RFE instruction, see RFE on page B9-2000. If a subtraction is required, typically it is
performed before saving the LR value to memory.
• In ARM state, a form of the LDM instruction, see LDM (exception return) on page B9-1986. If a subtraction is
required, typically it is performed before saving the LR value to memory

=========== Data/Prefetch Abort	===========
(Is this is a thing?)
Data fetch abort
The abort was caused by the instruction at lr - 8

Instruction fetch abort
The abort was caused by the instruction at lr - 4

Read fault type:
volatile unsigned int faulttype;
__asm volatile ("mrc p15, 0, %[ft], c5, c0, 0\n\t" : [ft] "=r" (faulttype));
faulttype &amp;= 0xf;


=========== Undefined Instruction ===========
// actual undefined instruction, for testing: 0xe7fxxxfx - ARM or A1 encoding (ARMv4T, ARMv5T, ARMv6, ARMv7)
// asm volatile (".word 0xe7f000f0\n"); /* arm illegal instruction */

(So, if I understand this correctly, LR will contain the address of the undefined instruction)
(Actually, I think the bad instruction ends up being LR - 4)
(could be wrong?)
Undefined instruction
The abort was caused by the instruction at lr

SWI and undefined instruction exceptions are
generated by the instruction itself
n lr_mode = pc + 4 //next instruction

The preferred return address for an Undefined Instruction exception is the address of the instruction that generated
the exception. This return is performed as follows:
• If returning from Secure or Non-secure Undefined mode, the exception return uses the SPSR and LR_und
values generated by the exception entry, as follows:
— If SPSR.{J, T} are both 0, indicating that the exception occurred in ARM state, the return uses an
exception return instruction with a subtraction of 4.

