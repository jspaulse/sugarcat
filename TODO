development flow (short term):
    spinlocks
    memory management:
	mmu
	    arch_mmu_interface
	vmm
	pmm
	heap
    mm_interface
    cpu_setup
	secondary_cpu_setup

Caching, domain, permission access
    mmu interface will probably have some sort of simplified permissions
    & caching for different regions
    
    It'll probably be a choice of three flags: USER | KERNEL | DEVICE
    which define access to the regions:
	User will be ACC_KRW_URW with cache
	Kern will be ACC_KRW_UNO(or URO) with cache
	Device will probably be ACC_KRW_UNO with no cache

Concept idea:
    For heap allocation (I.E., kmalloc, kfree)
	Have the heap descend downwards
	Put the heap at the top of memory
	    Should we pre allocate N number of virtual addresses?
	    
Concept idea:
    Wrap arch specific things! As an example, the mmu:
	mmu.c mmu_map(phy_page, virt_page, (DEVICE|CACHED), (KERNEL|USER))
	-> arch/armv7/mmu/armv7_arch_mmu.c -> arch_mmu_map(phy_page, virt_page)
	    -> arch/armv7/mmu/armv7_mmu.c -> armv7_mmu_map_pgtb(struct ...)
    So, anything that ends up being arch. specific will be required to provide an arch interface.

vexpress_init.c
    install_ivt()	- remove
    Fixup domain access
    Fixup region access (AP)
    
    init_mmu_entry
	flags doesn't make sense
	    it changes between different entries
	init_setup_kern_pgtb
	init_map_kern_pgtb
    armv7_mmu_set_kern_pgd(..)
	actually use flags

armv7_mmu.c/h
    introduce caching flags and all that jazzery.
    entry type support
	maybe move that to some sort of configuration?
	
Look at enabling all of the necessary caches and all that jazz.

Concept idea:
	When mapping phy->vm for i/o, keep track of requested regions (i.e., counter)
		so, if dev A&B need region X
			A-> mm_io_request_reg(X) creates a tracked entry (counter + 1) and returns a ptr
				(pointer returned is added for register use? since we're allocating pages)
			B-> mm_io_request_reg(X) returns the same ptr (added, of course)
			
		when a device no longer needs the region
			A-> mm_io_free_reg(X) decrements counter, if counter == 0 free, otherwise don't
			

PL011 UART (serial communication)
PL031 Real Time Clock
PL050 PS2 Mouse & Keyboard Interface	// http://wiki.osdev.org/PL050_PS/2_Controller
PL110/PL111 Color LCD/HDLCD (software rendering, no GPU)
	https://io.netgarage.org/arm/tmp/timpwn_firstpixels.c
	http://wiki.osdev.org/ARM_Integrator-CP_PL110_Dirty
	
	http://forum.osdev.org/viewtopic.php?f=1&t=23990, 
	http://stackoverflow.com/questions/10070192/arm-programming-pl111-controller-and-printing-characters-on-the-lcd
	https://github.com/CyberGrandChallenge/linux-source-3.13.11-ckt32-cgc/blob/master/drivers/video/amba-clcd.c
PL180 MultiMedia Card Interface (MMCI)

kinit/kinit_warn/panic
	Garbage functions, need better.
	panic should probably dump more

mm (Memory Manager)
    Oversees PMM, VMM and heap functions (kmalloc, kfree)
pmm (Physical Memory Manager):
    Handles allocation (and book keeping) of physical pages
	No Access outside of VMM
vmm (Virtual Memory Manager):
    Handles allocation of pages & iomapping
	(Probably no access outside of indirect access via mm)
		
Flow:
    vexpress_init
	branch into kernel init (pass kernel phy info, not ss though)
	    config base will need to evolve to whatever in high mem
		or, make sure it gets mapped and phy_to_virt() that shiz.

    kernel_init
	require 1:1 map of phy mem in lower table && kmphy->kmvirt
	    init pmm
		gets memory region - start & size
		    mark book keeping regions used
		    mark kernel regions used
	    init mmu
		in our case, requires 2MB continuous (or, 512 pages)
		map 2MB continuous in mmu
		do actual kernel mappings
	    init vmm
		    whatever that'll involve
	    init cpu (for reals)
		allocate pages for various stacks
	    init secondary cpu's
		allocate pages for various stacks, set mmu ttb1 to kern ttb1
